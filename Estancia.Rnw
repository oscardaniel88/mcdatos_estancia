\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage[table]{xcolor}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\begin{document}
<<knitr_options, include=FALSE>>=
opts_chunk$set(fig.width=14, fig.height=5, fig.path='figures/',
               warning=FALSE, message=FALSE, tidy=FALSE)
options(width=60)
#set.seed(53079239)
@

<<libraries, include=FALSE>>=
library(tidyverse)
library(Hmisc)
library(knitr)
library(ggplot2)
library(kableExtra)
library(corrplot)
library(ggrepel)
knitr::opts_chunk$set(echo = TRUE)
@

<<working_directlory, include=FALSE>>=
system <- Sys.info()
if(system["sysname"]=="Windows"){
  setwd("~/GitHub/mcdatos_estancia")
} else{
  setwd("~/Documents/CienciaDatos/GitHub/mcdatos_estancia")
}
historico_ocupacion<-read_csv("datos/EST_PAS_UNIC_CEINS.csv")
canales <- read_csv("datos/cat_canales.csv") %>% select(Id_Origen, Descripcion)
segmentos <- read_csv("datos/cat_segmentos.csv") %>% select(ID_SUBSEGM,Descripcion)
indicadores<-read_csv("datos/Indicadores_CEINS.csv")
competencia<-read_csv("datos/BOP_CEINS.csv") %>% select(nombre,fecha,precio)
TDC <- read.csv("datos/tdc.csv")
names(TDC) <- c("dia","tdc")
TDC$dia <- as.Date(TDC$dia)
reservasCEINS <- read_csv("datos/CEINS_RESERVAS.csv")
eventos <- read_csv("datos/eventos.csv") %>% select(hotel_clave,fecha,eventos)
names(eventos)<-c("hotel","dia","eventos")
eventos2018 <- eventos %>% filter(format(dia,"%Y")=="2017") %>% mutate(dia = dia +365)
eventos <- rbind(eventos,eventos2018)
price <- read_csv("datos/Prices.csv") %>% select (prop_code,rate_start,rate_key,curr_code,price_1pax) %>% filter(rate_start<='2018-08-11') %>% arrange(rate_start)
calidad <- read_csv("datos/calidad.csv") %>% arrange(plaza)
names(calidad)<-c("plaza","hotel","calidad")
@
\title{\Huge Modelo de Predicción de Demanda y Pricing Dinámico}
\author{Oscar Daniel Camarena Gómez}
\date{}
\maketitle
\pagenumbering{gobble}
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\section{Objetivo}
El objetivo del presente trabajo es generar un producto de datos que permita a la cadena de hoteles CityExpress pronosticar la demanda de ocupación de sus propiedades. Esto permitirá que el equipo comercial que opera las propiedades manipulen los precios de cada una de las tarifas disponibles de tal forma que puedan maximizar el ingreso de cada una de ellas.
~ \\ 
Para poder generar el modelo deseado CityExpress puso a nuestra disposición data sets que contienen información de las reservaciones generadas en cada una de las propiedades desde el año 2013, información de las reservaciones pendientes por llegar para el año 2018 - 2019, información de las principales variables hoteleras para la competencia e información de los precios de su competencia publicados en las agencias de viajes en línea (Expedia, Booking.com,etc).
~\\ 
Antes de hacer un análisis exhaustivo a los datos de la cadena, se hizo un análisis de negocio lo cual ayudó a que pudieramos dar un contexto social a la información que nos proporcionaron y a su vez ayudó a la interpretación de los resultados arrojados por los distintos análisis ejecutados.
\section {Contexto de Negocio} ~ \\
CityExpress es una cadena de hoteles 100\% mexicana enfocada al turismo de negocios. Actualmente cuenta con 140 hoteles en México y Latinoamérica (Colombia, Costa Rica y Chile). CityExpress cuenta con hoteles pensados para el viajero de negocios, sus instalaciones son prácticas, la tarifa es baja y ofrece servicios limitados pero valiosos durante un viaje de negocios, por ejemplo:
\begin{itemize}[noitemsep]
\item Internet gratuito en las habitaciones
\item Desayuno de cortesía
\item Transporte gratuito 10 km a la redonda
\item Servicio estandarizado con bajo costo
\end{itemize}
CityExpress cuenta con 4 marcas, cada una de ellas enfocada a distintos segmentos de mercado:
\begin{description}
\item [$\bullet$ CityExpress:] Marca emblema, enfocada al viajero de negocios. Los hoteles están ubicados cerca de los centros de negocios de las distintas ciudades en la República Mexicana.
\item [$\bullet$ CityExpress Plus:] Hoteles ubicados en las principales ciudades de la República Mexicana (CDMX, Guadalajara, Monterrey) y en Latinoamérica (Colombia). Ofrecen diseños vanguardistas y mayor espacio en las habitaciones.
\item [$\bullet$ CityExpress Suites:] Marca enfocada en los viajeros de larga estancia. Sus instalaciones cuentan con cocineta, estancia y habitaciones de mayor tamaño.
\item [$\bullet$ CityExpress Junior:] Hoteles de menor precio enfocados al turismo con presupuesto limitado ofreciendo un producto de calidad y con servicio estandarizado.
\end{description}
\paragraph {Ubicación} ~ \\
Típicamente un hotel de CityExpress está ubicado cerca de zonas industriales o zonas con fuerte actividad económica, es decir, en el caso de las grandes ciudades encontraremos hoteles CityExpress cerca de una zona donde hay alta densidad de locales comerciales, oficinas corporativas o centros de negocios. En el caso de ciudades mas pequeñas o con actividades económicas específicas encontraremos hoteles cerca de los centros económicos de cada una de las ciudades, este hecho permite que la cadena agrupe a sus hoteles en distintos \textbf{corredores} dependiendo de la actividad de las zonas económicas donde se encuentran. A continuación se presentan los distintos corredores:
\begin{itemize}[noitemsep]
\item Energético
\item Exportacion-Agricultura
\item Franquicia
\item Internacional
\item Manufactura
\item Maquila
\item Mineria
\item Servicios
\end{itemize}
\paragraph {Hoteles} ~ \\
Las propiedades de Hoteles CityExpress siguen un estándar desde su construcción hasta en su operación diaria. En cuanto al estándar de construcción las propiedades generalmente cuentan con 6 plantas, 120 habitaciones, un lobby para la recepción de huéspedes y áreas comunes; por ejemplo, área designada para fumar, desayunador, salas de juntas, salones de eventos y alberca (en algunas propiedades). 
En cuanto a las habitaciones el tamaño puede variar por marca, sin embargo ofrecen los mismos servicios independientemente de ella: 
\begin{itemize}[noitemsep]
\item Internet Gratuito
\item Área de Trabajo
\item Lavandería
\item Aire Acondicionado
\item Pantalla de televisión
\item Desayuno de cortesía
\end{itemize}
\paragraph {Crecimiento} ~ \\
Hoteles CityExpress fue fundada en 2002 con su primer hotel construido en Saltillo. A partir de ese entonces se ejecutó un ambicioso plan de crecimiento en el cuál se impuso la meta de abrir un nuevo hotel cada 6.8 semanas. Esto llevo a que la cadena de hoteles contara con más de 140 propiedades en un lapso de 16 años.
Hoy en día Hoteles CityExpress cuenta con propiedades en 34 de los 36 estados de la República Mexicana y 5 mas en Latinoamérica: 1 en Costa Rica, 1 en Chile, 3 en Colombia. El plan de crecimiento sigue siendo ambicioso y la cadena espera contar con 180 propiedades para el 2020.
\begin{figure}[!]
  \includegraphics[width=\linewidth]{Imagenes/Ubicaciones.png}
  \caption{Plan de crecimiento}
  \label{fig:crecimiento}
\end{figure}
\section{Descripción del Problema}
\subsection{Gestión de las propiedades}
Hoteles CityExpress cuenta con un modelo de gestión comercial de sus propiedades ejecutado desde sus oficinas centrales ubicadas en la Ciudad de México. Este modelo de gestión se enfoca en optimizar la venta de los cuartos de las distintas propiedades, buscando siempre maximizar el ingreso obtenido por estas ventas.
Para poder entender mejor el modelo de gestión comercial debemos estudiar antes los canales distribución que utiliza para la venta de sus productos así como sus distintos segmentos de mercado. Posteriormente presentaremos las principales variables utilizadas para calificar el desempeño de las propiedades así como las acciones que puede tomar cada uno de los gerentes de las propiedades para poder cambiar el desempeño del hotel.
\paragraph{Canales de Venta}
~\\
CityExpress cuenta con un modelo de venta estandarizado para todas sus propiedades. Este modelo de venta contempla distintos canales de distribución que ayudan al grupo a poder incrementar la oferta de su producto llegando a distintos segmentos de mercado.
Es importante mencionar que cada uno de los canales de venta tienen un costo asociado, es decir, del ingreso que se perciba por cada cuarto vendido se debe tomar en cuenta el costo de cada canal para poder calcular la utilidad bruta de la venta, por eso es. importante conocer cómo opera cada uno de ellos.
Dentro de CityExpress existen dos tipos de canales de venta: \textbf{Canales de venta tradicionales} y \textbf{Canales de venta electrónicos}. Los canales de venta tradicionales, son aquellos en los cuales se requiere la intervención de un agente de ventas, los electrónicos permiten que el cliente final realice su reservación sin requerir la intervención del agente:
\paragraph{\textbf{Canales de venta tradicionales}}
\begin{itemize}[noitemsep]
\item Centro de Contacto (Call Center)
\item Hotel
\end{itemize}
\paragraph{\textbf{Canales de venta electrónicos}}
\begin{itemize}[noitemsep]
\item App (IOS y Android)
\item Portal Cliente Frecuente (City Premios)
\item Motor de reservaciones corporativas (CityAccess)
\item Motor de reservaciones (www.cityexpress.com.mx)
\item Agencias de viajes en línea (OTAs)
\end{itemize}
\paragraph{Segmentos de Mercado}
~\\
Los segmentos de mercado son un punto medular para poder entender el modelo de gestión en CityExpress ya que estos permiten al área comercial poder establecer una estrategia de venta en cada uno de los canales fijando precios en las distintas tarifas para poder maximizar la ocupación del hotel y el ingreso por cuartos vendidos. ~\\
Típicamente un hotel cuenta con un conjunto de tarifas las cuales son ofrecidas a diferentes segmentos de mercado en diferentes canales. Por ejemplo, un huésped que viaja por placer y reserva por la página web de CityExpress muy probablemente recibirá una tarifa distinta al huésped que viaja por negocios y reservó por el centro de contacto.
~\\
A continuación se presentan los distintos segmentos de mercado manejados por CityExpress:
~\\
\textbf{Negocios}
\begin{itemize}[noitemsep]
\item Directos
\item Convenios
\item Viajero Frecuente
\item Corporativo
\item Consorcios
\item Promociones
\item Otros
\end{itemize}
~\\
\textbf{Placer}
\begin{itemize}[noitemsep]
\item Directos
\item Fin de Semana
\item Otros
\item Promociones
\end{itemize}
~\\
\textbf{Mayoreo}
\begin{itemize}[noitemsep]
\item Agencias Minoristas
\item OTAs
\item Lineas Aéreas / Tripulaciones
\item Agencias Mayoristas
\item Otros
\end{itemize}
~\\
\textbf{Grupos}
\begin{itemize}[noitemsep]
\item Grupos, Ferias, Congresos y Convenciones
\item Sociales
\item Juntas
\item Deportes
\end{itemize}
~\\
\textbf{Otros}
\begin{itemize}[noitemsep]
\item Uso Casa
\item Cortesías
\item Intercambio
\item Empleados
\item Industria Turística
\item Otros
\end{itemize}
\paragraph{Tarifas}
~\\
Como se mencionó anteriormente, un hotel tiene un catálogo de 36 tarifas que puede ofrecer a los huéspedes. Cada tarifa va dirigida a un segmento de mercado y un canal en específico. Hay tarifas que pueden cambiar de precio hasta 3 veces al día y hay otras que al ser tarifas convenidas con otras empresas, permanecen estáticas la mayor parte del año.
Es responsabilidad de cada uno de los hoteles el revisar los distintos reportes expuestos en la organización en donde pueden encontrar: sus niveles de ocupación, ocupación de la competencia, tarifas promedio propias, tarifas promedio de la competencia, penetración de ocupación: $\frac{\% ocupacion\ propia}{ \% ocupacion\ de\ la\ competencia}$ y penetración de tarifa: $\frac{tarifa\ promedio\ propia}{tarifa\ promedio\ de\ la\ competencia}$ para decidir si deben hacer un incremento o decremento en los precios ofertados.
\paragraph{Variables estudiadas}
~\\
Dentro de CityExpress las decisiones de cambios de precios en las tarifas se toma analizando distintas variables. La mayoría de estas variables se alimentan de información propia del grupo hotelero aunque hay algunas que se obtienen de información de la competencia. A continuación se detallará cada una de las variables utilizadas durante la toma de estas decisiones:
\begin{itemize}[noitemsep]
\item \%Ocupacion
\item Tarifa Promedio
\item Tarifa Efectiva
\item Penetración de Ocupación
\item Penetración de Tarifa
\item Eventos por plaza
\item \%Ocupación de la competencia
\item Tarifa Promedio de la competencia
\item Tarifa Efectiva de la competencia
\end{itemize}
~\\
Derivado de las conclusiones del análisis de estas variables, los hoteles y el equipo de la oficina central pueden tomar alguna de las siguientes decisiones para alcanzar el objetivo deseado:
\begin{itemize}[noitemsep]
\item Subir precio de tarifa
\item Bajar precio de tarifa
\item Abrir un canal de venta
\item Cerrar un canal de venta
\item Promover la venta de un segmento específico mediante una promoción
\item Inhibir la venta de un segmento en específico cerrando disponibilidad de alguna tarifa
\end{itemize}
\subsection{Situación Actual}
~\\
Como se mencionó en el apartado anterior, hoy en día CityExpress gestiona su estrategia comercial desde las oficinas centrales delegando tareas clave a cada uno de los gerentes de las distintas propiedades, esto aunado al ambicioso plan de crecimiento de la cadena ha hecho que este modelo de gestión comercial se vuelva un proceso complicado de administrar y ejecutar de manera efectiva ya que se tienen las siguientes dependencias en el proceso:
\begin{itemize}[noitemsep]
\item Publicación de reportes diarios
\item Análisis de información publicada
\item Presentación de plan de acción de acuerdo al modelo de gestión
\item Aprobación del plan de acción por parte de la oficina central
\item Ejecución del plan de acción en los sistemas de control
\item Validación de resultados del plan de acción
\end{itemize}
\subsection{Propuesta de mejora al proceso}
~\\
Este proyecto tiene como objetivo mejorar el proceso de gestión de hoteles en CityExpress mediante la construcción de un sitio en donde se integre toda la información que hoy en día se expone en distintos reportes dentro de la empresa y además cuente con un modelo que permita pronosticar el $\%\ de\ ocupacion$ de cada una de las propiedades y a su vez haga una recomendación del precio para la tarifa que se ofrece al público en general que ayude a maximizar el ingreso por venta de cuartos dentro de la propiedad.
Con esta herramienta se espera que el modelo de gestión comercial se automatice y la ejecución del plan de acción se realice de manera más ágil.
\section{Metodología Propuesta}
\subsection{Plan de implementación}
~\\
A continuación se presentan los pasos que se siguieron para la implementación de este nuevo sistema de gestión:
\begin{description}
\item [$\bullet$ Entendimiento del negocio:]  Antes de construir una herramienta / producto de datos se dedicó un tiempo a conocer los procesos operativos de la cadena hotelera.
\item [$\bullet$ Entendimiento del sistema de gestión comercial:] Para que el producto final agregue verdadero valor a la empresa se debió comprender el tramo de control de cada puesto operativo destinado a hacer uso de esta herramienta, es decir, se identificaron las acciones que cada usuario puede ejecutar en los distintos sistemas para alcanzar sus objetivos comerciales.
\item [$\bullet$ Identificación de posibles fuentes de datos:] Una vez comprendidos los procesos operativos y de toma de decisiones, se identificaron los sistemas que proveen la información que ayuda al personal de CityExpress durante la toma de decisiones.
\item [$\bullet$ Análisis exploratorio de datos:] Una vez identificadas las fuentes de datos, se ejecutó un análisis exploratorio de datos con el fin de poder conocer los datos con que se trabajaron para posteriormente fijar un alcance para el producto final.
\item [$\bullet$ Modelo de predicción de ocupación y sugerencia de precios:] Una vez perfilados los datos y con un EDA concluido se realizó un esfuerzo para construir un modelo que fuera capaz de pronosticar el $\%\ de\ ocupacion$ y que sugiriera el $precio\ publico$ óptimo de cada una de las propiedades.
\item [$\bullet$ Construcción de prototipo de producto de datos:] Se definió la arquitectura final del producto de datos y se construyó un prototipo totalmente funcional que apoya la toma de decisiones de los participantes del proceso de gestión comercial.
\end{description}
\subsection{Fuentes de datos}
~\\
Una vez hecho el análisis de negocio y conociendo la operación de CityExpress, detectamos que las fuentes principales para la construcción del producto de datos son las siguientes:
\begin{itemize}
\item \textbf{Central de Reservaciones}: Módulo encargado de realizar las reservaciones de cuartos en las distintas propiedades. De este sistema obtuvimos el comportamiento histórico de cada una de las propiedades, es decir, cuantas habitaciones fueron reservadas, en qué momento y con qué tarifa.
\item \textbf{Property Management System (PMS)}: Módulo encargado de gestionar las propiedades. Aquí se pueden consultar las habitaciones ocupadas, disponibles y fuera de servicio, así como las llegadas y salidas del día. De este sistema obtuvimos las reservaciones en libros (bookings) o llegadas pendientes, esta información es crucial para poder conocer en la demanda real de cada una de las propiedades en el tiempo.
\item \textbf{Market Share}: Sistema encargado de recopilar la información de la competencia. Las variables recopiladas son Tarifa Promedio, Habitaciones Disponibles, Habitaciones ocupadas, entre otras. 
\item \textbf{Tarifas de la competencia}: Consulta de las tarifas disponibles en las agencias de viajes en línea para la competencia.
\end{itemize}
\subsection{Análisis Exploratorio de Datos}
A continuación se mostrará a detalle análisis exploratorio realizado al dataset inicial. Este data set comprendía información de 5 hoteles y el objetivo de este era brindar un apoyo a la comprensión de los datos para poder establecer una metodología de trabajo al momento de crear un modelo de predicción de demanda para cada una de las propiedades. Para fines de este trabajo detallaremos el "EDA" utilizando datos de una sola propiedad: "CEXXX".
\paragraph{Descripción del DataSet} ~\\
Durante la construcción del modelo se hizo uso de tres datasets principalmente. El primero de ellos llamado "histórico\_ocupación" fue obtenido del sistema de gestión de propiedades \textbf{(PMS)} y contiene la información del desempeño histórico de las propiedades. A continuación se presenta un resumen del data set en cuestión.

<<summary, echo=FALSE>>=
summary(historico_ocupacion)
@
~\\
A continuación se presenta el diccionario de datos para el data set presentado:
\begin{itemize}[noitemsep]
\item rsrv\_code: Código de confirmación de reserva
\item date\_create: Fecha de creación de la reserva
\item date\_in:Fecha de entrada al hotel
\item date\_out: Fecha de salida del hotel
\item nights: Número de noches en el hotel
\item prop\_code: Código de Hotel
\item mkt\_sgm: Segmento de Mercado
\item Dia\_Sem: Dia de la semana para la fecha de entrada al hotel
\item rate\_code: Código de tarifa
\item bucket: Nivel de tarifa
\item Ingresos: Ingresos obtenidos por la reservación
\item rsrv\_src: Canal de la reservación
\item rsrv\_type: Tipo de reservación
\item room\_type: Tipo de habitación
\item PAX: Personas amparadas por la reservación
\end{itemize}
~\\
Revisando el resumen de este data set es importante resaltar que los datos fueron trabajados previamente para presentarse de manera desagregada, es decir, si una reserva ampara una estancia de 5 noches tendremos un registro por cada noche de la estancia, por ejemplo:
~\\
<<registros, echo=FALSE>>=
reservas<-historico_ocupacion %>% filter(rsrv_code == 6265739) %>% select(rsrv_code,date_create,date_in,date_out,nights,room_type)
kable(reservas, "latex") %>% 
kable_styling(latex_options = "striped")
@
Como podemos observar el numero de reservación es el mismo en los 6 registros, lo mismo ocurre con la fecha de creación, las noches, y el tipo de habitación, sin embargo, la fecha de entrada y la fecha de salida va cambiando en cada registro. En algunos casos es más fácil trabajar con los registros desagregados, sin embargo hay casos en dónde necesitaremos agrupar la información.

\paragraph{Ocupación} ~\\
De las primeras preguntas que se vienen a la mente al momento de analizar la información de esta propiedad es ¿Qué nivel de ocupación tiene este hotel a lo largo del tiempo? Para contestar esta pregunta, se generáron las siguientes gráficas:
~\\
<<HabitacionesOcupadas, echo=FALSE>>=
tl_habocup <- historico_ocupacion %>% group_by(date_in) %>% summarise(nights=sum(nights))
ggplot(tl_habocup, aes(date_in, nights)) + geom_line() +
 xlab("") + ylab("Cuartos Ocupados")+ theme_bw() + theme(axis.text=element_text(size=16),
        axis.title=element_text(size=16,face="bold"))

##ggsave("Tesis/Figures/HabitacionesOcupadas-1.pdf")
@
~\\
<<Ocupacion, echo=FALSE>>=
tl_ocup <- historico_ocupacion %>% group_by(date_in) %>% summarise(ocupacion=sum(nights)/159)
ggplot(tl_ocup, aes(date_in, ocupacion)) + geom_line() +
 xlab("") + ylab("% Ocupacion")+ theme_bw() +theme(axis.text=element_text(size=16),
        axis.title=element_text(size=30,face="bold"))
@
~\\
Como podemos observar esta propiedad tiene niveles de ocupación alrededor del 75\% llegando en repetidas ocasiones al 100\% de ocupación. Las caídas en los níveles de ocupación se deben a los fines de semana. A continuación presentamos una gráfica que nos ayudará a sustentar esta conclusión.
~\\
<<Ocupacion Dia Semana, echo=FALSE>>=
ocup_dia_sem <- historico_ocupacion %>% group_by(date_in) %>% summarise(nights=sum(nights),
                                                                        dia_sem = min(Dia_Sem),
                                                                        count_sem = 1) %>% 
                                                              group_by(dia_sem) %>% summarise(nights=sum(nights),
                                                                                              semanas = sum(count_sem)) %>% 
                                                              mutate(ocup=nights/(semanas*159))

ggplot(ocup_dia_sem, aes(dia_sem,ocup)) + geom_bar(stat="identity") +
 xlab("Dia de la semana") + ylab("% Ocupacion")+
  scale_x_discrete(limits=c("lun","mar","mie","jue","vie","sab","dom"))+ theme_bw() + theme(axis.text=element_text(size=16),
        axis.title=element_text(size=30,face="bold"))

@
\paragraph{Pickup} ~\\
Al realizar este tipo de análisis resulta interesante estudiar el tiempo de antelación con el cual el cliente reserva un cuarto, a esto se le llama curva de pickup. Para poder graficar esta curva necesitaremos agrupar los datos por numero de reservación obteniendo la mínima fecha de entrada y la máxima fecha de salida para cada una de ellas. Una vez trabajados los datos podremos calcular la antelación obteniendo la diferencia entre la fecha de entrada y la fecha de creación en días.
~\\
<<pickup, echo=FALSE>>=
historico_grp_rsrv <- historico_ocupacion %>% group_by(rsrv_code) %>% summarise(nights=sum(nights),
                                                                      date_create = min(date_create),
                                                                      date_in = min(date_in),
                                                                      date_out = max(date_out),
                                                                      count = 1)
historico_grp_rsrv$antelacion<-as.integer(difftime(historico_grp_rsrv$date_in,historico_grp_rsrv$date_create, units="days"))
pickup_rsrv <- historico_grp_rsrv %>% group_by(antelacion) %>% summarise(reservas=sum(count))
pickup_rsrv$reservas<-rev(cumsum(rev(pickup_rsrv$reservas)))
ggplot(pickup_rsrv, aes(antelacion, reservas)) + geom_line() + xlim(-1,100) + ggtitle("Pickup 100 dias")

@
~\\
<<pickupzoom, echo=FALSE>>=
ggplot(pickup_rsrv, aes(antelacion, reservas)) + geom_line() + xlim(-1,25) + theme_bw()+theme(axis.text=element_text(size=16),
        axis.title=element_text(size=30,face="bold"))
@
\paragraph{Pickup por Canal de Venta} ~\\
Como podemos observar en la gráfica "Pickup 25 días" el mayor número de reservaciones en esta propiedad ocurre 5 días antes de que el huésped llegue al hotel. Con esto podemos concluír que los clientes que visitan esta propiedad planean su estancia con a lo más 5 días de antelación. 
Resulta interesante ampliar este análisis para cada uno de los canales de reservación disponibles.
~\\
<<pickupsrc, echo=FALSE>>=
historico_grp_rsrv_src <- historico_ocupacion %>% group_by(rsrv_code,rsrv_src) %>% summarise(nights=sum(nights),
                                                                      date_create = min(date_create),
                                                                      date_in = min(date_in),
                                                                      date_out = max(date_out),
                                                                      count = 1)%>% left_join(canales, by=c("rsrv_src"="Id_Origen"))
historico_grp_rsrv_src$antelacion<-as.integer(difftime(historico_grp_rsrv_src$date_in,historico_grp_rsrv_src$date_create, units="days"))
pickup_src <- historico_grp_rsrv_src %>% group_by(Descripcion,antelacion) %>% summarise(reservas=sum(count)) 
pickup_src <- pickup_src %>% group_by(Descripcion) %>% mutate(reservas = rev(cumsum(rev(reservas))))
ggplot(pickup_src, aes(antelacion, reservas)) + geom_line() + xlim(-1,25) + facet_wrap(~Descripcion) + ggtitle("Pickup por Canal de Reserva")
@
~\\
Podemos notar que para este hotel en particular el pickup es similar (alrededor de 5 días de antelación) en los canales que producen ventas de cuartos, sin embargo resulta interesante observar que no todos los canales tienen una producción significativa en esta propiedad ya que el grueso de las ventas se concentra en los siguientes canales:
\begin{itemize}[noitemsep]
\item Contact Center
\item Hotel
\item Ota's
\item Internet (Website)
\item GDS's
\end{itemize}
\paragraph{Canales de Venta} ~\\
<<reservacionesxcanal, echo=FALSE, fig.width=20, fig.height=15>>=
produccion_src <- historico_grp_rsrv_src %>% group_by(Descripcion) %>% summarise(reservas = sum(count),
                                                                                 cuartos = sum(nights)) %>% arrange(-reservas)
ggplot(produccion_src, aes(reorder(Descripcion,-reservas),reservas)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 60, hjust = 1)) +xlab("canal") + ggtitle("Reservas por Canal")
@
~\\
Por último estudiaremos cómo se comporta cada uno de los canales a lo largo del día, esto para poder encontrar un patrón en el uso de cada uno de los canales.
~\\
<<CorrelacionHoraCanal, echo=FALSE, fig.width=20, fig.height=15>>=
corr_hour<-historico_ocupacion %>% left_join(canales, by=c("rsrv_src"="Id_Origen")) %>% select(date_create,Descripcion,nights) %>% mutate(hour=format(date_create,"%H")) %>% group_by(hour,Descripcion) %>% summarise(count=as.numeric(sum(nights)))
corr_hour$hour <- as.numeric(corr_hour$hour)
corr_hour<- corr_hour %>% spread(Descripcion, count)
corr_hour[is.na(corr_hour)]<-0
corr_hour <- as.matrix(corr_hour)
corr_hour_hist<-historico_ocupacion %>% left_join(canales, by=c("rsrv_src"="Id_Origen")) %>% select(date_create,Descripcion,nights) %>% mutate(hour=format(date_create,"%H")) %>% select(hour,Descripcion)
ggplot(corr_hour_hist, aes(hour)) +geom_bar()+theme(axis.text.x = element_text(angle = 60, hjust = 1))+ facet_wrap(~Descripcion)
@
~\\
Con la gráfica anterior podemos corroborar los canales de venta más activos para este hotel y podemos concluír también que las horario en el que esta propiedad genera más reservaciones es de 9:00 am a 9:00 pm, con excepción del canal "walk in" el cuál tiene una distribución uniforme en las reservas generadas a lo largo del día.
\paragraph{Segmentos de Mercado} ~\\
Como se mencionó anteriormente, City Express implementa una segmentación de mercado en cada una de las reservaciones que genera, esto nos permitirá analizar el perfil del huésped que visita cada una de las propiedades. A continuación presentaremos un análisis partícular para una de las propiedades.
A continuación se presentan los segmentos de mercado y las reservaciones que produjeron durante un periodo de tiempo:
~\\
<<SegmentosMercado, echo=FALSE, fig.width=20, fig.height=15>>=
historico_mkt <- historico_ocupacion %>%left_join(segmentos, by=c("mkt_sgm"="ID_SUBSEGM")) %>%  group_by(rsrv_code) %>% summarise(nights=sum(nights),
                                                                      date_create = min(date_create),
                                                                      date_in = min(date_in),
                                                                      date_out = max(date_out),
                                                                      mkt_sgm = min(mkt_sgm),
                                                                      count = 1)
historico_mkt_rsrv <- historico_mkt %>% left_join(segmentos, by=c("mkt_sgm"="ID_SUBSEGM")) %>% group_by(Descripcion) %>% summarise(reservas=sum(count)) %>% arrange(-reservas)

ggplot(historico_mkt_rsrv, aes(reorder(Descripcion,-reservas),reservas)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 60, hjust = 1)) +xlab("Segmento") + ggtitle("Reservas por Segmento")
@
~\\
Derivado de este analisis podemos observar lo siguiente:
Los segmentos que mas reservan son:
\begin{itemize}[noitemsep]
\item OTA's (Agencias de Viaje en línea)
\item Negocios-Convenios (Empresas con tarifa convenio)
\item Negocios-Directos (Viajeros de negocios sin tarifas convenio)
\item Negocios-Promociones (Viajeros de negocios con cupones promocionales)
\end{itemize}
Podemos decir que el perfil del huésped que visita esta propiedad es el viajero de negocios que visita oficinas corporativas cercanas a la ubicación del hotel durante la semana laboral (Lunes - Viernes).
\paragraph{Producción de Cuartos por Segmentos} ~\\
Contrastaremos la gráfica anterior contra la producción de cuartos vendidos por cada uno de los segmentos para poder tener una ídea de cuantos cuartos vende cada segmento en cada una de las reservaciones generadas.
~\\
<<SegmentosMercadoCNO, echo=FALSE, fig.width=20, fig.height=15>>=
historico_mkt <- historico_ocupacion %>%left_join(segmentos, by=c("mkt_sgm"="ID_SUBSEGM")) %>%  group_by(rsrv_code) %>% summarise(nights=sum(nights),
                                                                      date_create = min(date_create),
                                                                      date_in = min(date_in),
                                                                      date_out = max(date_out),
                                                                      mkt_sgm = min(mkt_sgm),
                                                                      count = 1)
historico_mkt_cno <- historico_mkt %>% left_join(segmentos, by=c("mkt_sgm"="ID_SUBSEGM")) %>% group_by(Descripcion) %>% summarise(cuartos=sum(nights)) %>% arrange(-cuartos)

ggplot(historico_mkt_cno, aes(reorder(Descripcion,-cuartos),cuartos)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 60, hjust = 1)) +xlab("Segmento") + ggtitle("Produccion de Cuartos por Segmento")
@
~\\
Podemos notar que el segmento de Negocios-Convenios produce más cuartos en un menor número de reservas, al contrario de las OTA's que producen mas reservaciones con menos venta de cuartos.
\paragraph{Estancia Promedio por Segmento} ~\\
A continuación graficaremos la estancia promedio de cada uno de los segmentos, esta medida nos deja ver cuantas noches pasa un huésped dentro de una propiedad. La fórmula para obtener esta variable es: $ Estancia\ Promedio=\frac{Cuartos Vendidos}{Reservas Generadas}$.
~\\
<<EstanciaPromedio, echo=FALSE, fig.width=20, fig.height=15>>=
historico_mkt <- historico_ocupacion %>%left_join(segmentos, by=c("mkt_sgm"="ID_SUBSEGM")) %>%  group_by(rsrv_code) %>% summarise(nights=sum(nights),
                                                                      date_create = min(date_create),
                                                                      date_in = min(date_in),
                                                                      date_out = max(date_out),
                                                                      mkt_sgm = min(mkt_sgm),
                                                                      count = 1)
historico_mkt_eprom <- historico_mkt %>% left_join(segmentos, by=c("mkt_sgm"="ID_SUBSEGM")) %>% group_by(Descripcion) %>% summarise(eprom=sum(nights)/sum(count)) %>% arrange(-eprom)

ggplot(historico_mkt_eprom, aes(reorder(Descripcion,-eprom),eprom)) + geom_bar(stat="identity") + theme(axis.text.x = element_text(angle = 60, hjust = 1)) +xlab("Segmento") + ggtitle("Estancia Promedio por Segmento")
@
~\\
Como podemos ver, la estancia promedio más alta la tiene el segmento de Negocios-Directos, con una estancia promedio de aproximadamente tres noches, contrastada con el segmento de Placer-Otros con una estancia promedio de aproximadamente noche. Esta información nos ayuda a complementar el perfil del huésped para esta propiedad ya que nos refuerza la idea de que el viajero de negocios utiliza las propiedades durante la semana laboral, y un viajero de placer puede que se hospede un día en fin de semana.
~\\
El segundo data set con el que contamos, trae información diaria sobre los níveles de ocupación, tarifa promedio, tarifa efectiva, habitaciones disponibles, penetración de ocupación y penetración de tarifa para los hoteles sujetos al estudio. Para efectos de este trabajo tomaremos información sobre el hotel con el que hemos venido trabajando.
<<SummaryIndicadores, echo=FALSE>>=
indicadores <- indicadores %>% filter(fecha<="2018-08-11")
summary(indicadores)
@
~\\
Lo primero que podemos observar es que contamos con datos para el hotel CEXXX a partir del "2013-01-01" y hasta el "2018-11-11". Esta propiedad tiene 159 habitaciones disponibles y maneja niveles de ocupación alrededor del 81.7\%; su tarifa promedio se encuentra alrededor de \$1486.60 y con PO y PT muy cercana a 1 indicando que es un hotel fuerte dentro del set competitivo de la plaza.
A continuación presentamos los datos de manera gráfica.
\paragraph{Ocupación en el tiempo} ~\\
<<IndicadoresOcupacion, echo=FALSE>>=
ggplot(indicadores, aes(fecha, occ)) + geom_line() +
 xlab("") + ylab("% Ocupacion")+ggtitle("% Ocupacion") + geom_smooth()
@
\paragraph{Tarifa Promedio en el tiempo} ~\\
<<IndicadoresTarifaPromedio, echo=FALSE>>=
ggplot(indicadores, aes(fecha, tp)) + geom_line() +
 xlab("") + ylab("TP" )+ggtitle("Tarifa Promedio") + theme_bw() +theme(axis.text=element_text(size=16),
        axis.title=element_text(size=30,face="bold"))
@
\paragraph{Penetración de Ocupación en el tiempo} ~\\
<<IndicadoresPO, echo=FALSE>>=
ggplot(indicadores, aes(fecha, po)) + geom_line() +
 xlab("") + ylab("PO" )+ggtitle("Penetracion Ocupacion") + geom_smooth()
@
\paragraph{Penetración de Tarifa en el tiempo} ~\\
<<IndicadoresPT, echo=FALSE>>=
ggplot(indicadores, aes(fecha, pt)) + geom_line() +
 xlab("") + ylab("PT" )+ggtitle("Penetracion Tarifa") + geom_smooth()
@
\paragraph{Penetración de Ocupación vs Penetración de Tarifa} ~\\
Al estudiar los datos notamos que hay una correlación negativa entre la penetración de ocupación y la penetración de la tarifa, recordemos que la primera indica cuanta ocupación tiene una de las propiedades de CityExpress con respecto a la ocupación de su plaza, y la segunda indica cuánto del ingreso disponible se está quedando dentro de la propiedad de interés. En otras palabras podemos pensar en una relación similar a la del precio de un bien vs la demanda de un bien. A mayor precio menor demanda y a menor precio mayor demanda, lo cual indica que la relación entre ambas variables debe ser negativa.
~\\
<<POvsPT, echo=FALSE>>=
ggplot(indicadores, aes(po, pt)) + geom_point(alpha=0.3) + geom_smooth(method='lm',formula=y~x,) +
 xlab("PO") + ylab("PT" )+ggtitle("PO vs PT") 
@
\paragraph{Precio de la competencia} ~\\
Para este proyecto contamos con un dataset que contiene información sobre los precios de la competencia definida para CEXXX publicados en las agencias de viajes en línea.
~\\
<<PrecioCompetencia, echo=FALSE>>=
summary(competencia)
@
\paragraph{Precios en el tiempo} ~\\
<<PreciosGraf, echo=FALSE>>=
ggplot(competencia, aes(fecha,precio,colour=nombre)) + geom_line()
@
~\\
Nos llaman la atención algunos datos que salen del patrón del comportamiento, para estudiarlos con mas detalle veamos la siguiente gráfica:
~\\
<<PreciosBoxPlot, echo=FALSE,fig.width=20, fig.height=15>>=
ggplot(competencia, aes(nombre,precio)) + geom_boxplot(outlier.colour="red", outlier.shape=1,
                outlier.size=2)+ theme(axis.text.x = element_text(angle = 60, hjust = 1))
@
~\\
Podemos observar que este data set contiene datos atípicos, por ejemplo los hoteles "Courtyard by Marriot Mexico City Revolución", "Holiday Inn Mexico City-Plaza Universidad" y "Holiday Inn Mexico City - Trade Center" tienen tarifas arriba de los \$10,000 MXN, lo cual es poco probable ya que son hoteles que compiten directamente con CityExpress y su mercado es el mismo (Viajero de Negocios). Estos casos se deberán tomarse en cuenta al momento de construír el modelo de pronóstico y pricing dinámico para evitar resultados erróneos. 
\paragraph{Precios publicos}
Estudiaremos también los precios públicos para la propiedad que esta siendo sujeta al análisis
<<Preciospublicos, echo=FALSE>>=
summary(price)
@
\paragraph{Precios publicos en el tiempo} ~\\
<<PreciospubGraf, echo=FALSE>>=
ggplot(price, aes(rate_start,price_1pax)) + geom_line() + geom_smooth()

@
~\\
<<Boxplotpubprice, echo=FALSE>>=
ggplot(price, aes(prop_code,price_1pax)) + geom_boxplot(outlier.colour="red", outlier.shape=1,
                outlier.size=2) + geom_smooth()
@
~\\
\paragraph{Calidad}
~\\
<<Calidad, echo=FALSE>>=
summary(calidad)
@
~\\
\paragraph{Calidad vs Precio}
~\\
<<CalidadvsPrecio, echo=FALSE>>=
calidad <- calidad %>% filter(plaza == "CEINS")
calidad$id <- c(1,2,3,4,5,6,7,8,9,10)
calcomp <- competencia %>% filter(fecha=="2018-08-11")
calcomp$id <- c(9,2,4,5,6,7,8,1)
calidadvsprecio<-calidad %>%  inner_join(calcomp) %>% select(hotel,calidad,precio)
ggplot(calidadvsprecio, aes(calidad,precio)) + geom_point() + geom_label_repel(aes(label = hotel),
                  box.padding   = 0.35, 
                  point.padding = 0.5,
                  segment.color = 'grey50') +
  theme_classic()
@
\paragraph{Tipo de Cambio}~\\
Otro data set con el que contamos es el tipo de cambio, a continuación mostramos las series de tiempo para el tipo de cambio:
~\\
<<TiposdeCambio, echo=FALSE>>=
ggplot(TDC, aes(dia,tdc)) + geom_line() + geom_smooth() +ggtitle("Serie de Tipos de Cambio")
@
\paragraph{Correlación de variables}~\\
Para concluír el análisis exploratorio de datos estudiaremos la correlación de cada una de las variables contra el nível de ocupación, esto nos ayudará a decidir qué variables debemos utilizar dentro del modelo construído.
~\\
<<Correlacion, echo=FALSE, fig.width=20, fig.height=15>>=
datoscorr <- reservasCEINS %>% select(prop_code,date_in,nights,Dia_Sem) %>% group_by(prop_code,date_in,Dia_Sem) %>% summarise(nights=sum(nights)) %>% mutate(occ=nights/159)
datoscorr$date_in <- as.Date(datoscorr$date_in)
id<-seq(1:7)
dia<-c("lun","mar","mie","jue","vie","sab","dom")
dias_sem<-as.data.frame(cbind(id,dia))
datoscorr<-inner_join(datoscorr,TDC, by=c("date_in"="dia")) %>% inner_join(indicadores,by=c("prop_code"="Hotel","date_in"="fecha")) %>% inner_join(dias_sem,by=c("Dia_Sem"="dia"))

datoscorr$prop_code<-as.numeric(as.factor(datoscorr$prop_code))
datoscorr$date_in<-as.numeric(as.factor(datoscorr$date_in))
datoscorr$id<-as.numeric(as.factor(datoscorr$id))
datoscorr<-datoscorr[,-3]
datoscorr<-datoscorr[,-4]
names(datoscorr)<-c("hotel","date_in","nights","tdc","occ","habs_disp","tp","po","pt","te","id")
cormat<-round(cor(datoscorr),2)
library(reshape2)
melted_cormat <- melt(cormat)
# Melt the correlation matrix
ggheatmap <- ggplot(melted_cormat, aes(Var2, Var1, fill = value))+
 geom_tile(color = "white")+
 scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
   midpoint = 0, limit = c(-1,1), space = "Lab", 
    name="Pearson\nCorrelation") +
  theme_minimal()+ # minimal theme
 theme(axis.text.x = element_text(angle = 45, vjust = 1, 
    size = 12, hjust = 1))+
 coord_fixed()

ggheatmap + 
geom_text(aes(Var2, Var1, label = value), color = "black", size = 4) +
theme(
  axis.title.x = element_blank(),
  axis.title.y = element_blank(),
  panel.grid.major = element_blank(),
  panel.border = element_blank(),
  panel.background = element_blank(),
  axis.ticks = element_blank(),
  #legend.justification = c(1, 0),
  #legend.position = c(0.6, 0.7),
  legend.direction = "horizontal")+
  guides(fill = guide_colorbar(barwidth = 7, barheight = 1,
                title.position = "top", title.hjust = 0.5))
@
~\\
\paragraph{Duración de Estancia}~\\
<<LOS1, echo=FALSE>>=
los<-historico_grp_rsrv %>% group_by(nights) %>% summarise(count=sum(count))
los$prob <- los$count/sum(los$count)
los <- los %>% filter(nights<435)
ggplot(data = los, aes(x=nights,y=prob))+geom_line()
@
~\\
Podemos ver que la longitud de estancia se concentra entre 0 y 10 noches, por lo tanto estudiaremos este intervalo de cerca
~\\
<<LOS2, echo=FALSE>>=
los <- los %>% filter(nights<11)
ggplot(data = los, aes(x=nights,y=prob))+geom_line()

@
~\\

Derivado de este análisis podemos concluir lo siguiente:
\paragraph{Conclusiones}

\subsection{Propuesta de Modelo Predictivo}
\paragraph{Antecedentes del modelo} ~\\
Se le ha llamado "yield management" a la estrategia de variar precios basándose en el entendimiento, anticipación e influenciando el comportamiento de los clientes con el fin de poder maximizar el ingreso o utilidad generada por la venta de un inventario fijo de productos perecederos o que tienen un tiempo de venta limitado (como asientos en un vuelo o cuartos de hotel). La estrategia de "yield management involucra una estrategia de control de inventario para vender el producto correcto al cliente correcto en el tiempo correcto por un precio correcto. Dicho proceso puede resultar en una discriminación de precio, en la cual clientes consumiendo el mismo producto o servicio pagan precios totalmente diferentes. 
~\\
Para poder aplicar el concepto de "yield management" necesitamos que se den tres condiciones:
\begin{itemize}[noitemsep]
\item Debe existir un inventario fijo disponible para la venta.
\item Los productos deben de ser perecederos (o deben contar con un tiempo limite de venta. Una vez transcurrido este tiempo el producto pierde su valor).
\item Diferentes clientes están dispuestos a pagar diferentes precios por el mismo producto.
\end{itemize}
~\\
Las estrategias de "yield management" han alterado la industria del transporte y hospitalidad desde los años 80's. Desde el momento en el que estas estrategias fueron concebidas, estas empresas han requerido contar con analistas con un conocimiento detallado del mercado asi como con sistemas computacionales avanzados en los cuales se implementan sofisticados técnicas matemáticas que analizan el comportamiento del mercado y capturan oportunidades de ingresos.
~\\
\paragraph{Yield Management en la hotelería}~\\
En el caso de uso específico para la hotelería podemos estudiar la venta de habitaciones como la venta de un inventario fijo (dificilmente se puede incrementar o cambiar), que además las habitaciones que no se venden cada noche dejarán de producir ingresos a la propiedad por lo que se puede decir que caducaron. Es por ello que algunos hoteles utilizan software especializado para monitorear como es que los cuartos están siendo vendidos y reaccionar con base en sus observaciones. Hay varios métodos de control del inventario por ejemplo, ofrecer descuentos en propiedades con baja demanda o caso contrario, aumentar precios en propiedades con alta demanda. Otra forma de controlar el inventario es mediante la venta anticipada, es decir, se reserva parte del inventario para la venta anticipada a 30 días, 15 días, 7 días y un día y conforme se van agotando los cuartos los precios van cambiando, de tal forma que si pocos cuartos de una categoría han sido reservados, los precios para esa categoría bajan.
~\\
\paragraph{Trabajo previo}~\\
Existe una gran cantidad de literatura que describe trabajos realizados previamente con el objetivo de construír un modelo que pronostique la demanda de un producto y a partir de este pronóstico se fije un precio que maximize el ingreso del inventario.
~\\
Para la construcción de este modelo se revisaron artículos disponibles así como trabajos previos en esta área y se obtuvieron las siguientes conclusiones:
\begin{itemize}[noitemsep]
\item La mayoría de los modelos construídos anteriormente parten el problema de pricing en dos:
\subitem Modelo de pronóstico de demanda
\subitem Modelo de pricing dinámico
\item La mayoría de los artículos utilizan una simulación de montecarlo para simular la ocupación a futuro de las propiedades
\item Se debe estudiar cuidadosamente la temporalidad de la ocupación en el hotel
\item Se pueden utilizar factores multiplicadores que dependen de una serie de variables para poder asignar el nuevo precio del producto.
\item La demanda de la propiedad (en el caso de hoteles) puede ser modelada como un proceso poisson.
\item Se pueden incluír heurísticas de control de inventario, aunque esto tiende a complicar el modelado.
\item El precio dependerá también del inventario que aún está disponible en cualquier momento en el que se dé una reservación.
\end{itemize}
~\\
Tomamos estas conclusiones como punto de partida para el modelo realizado en CityExpress.

\paragraph{Descripción del modelo} ~\\
Para el desarrollo del modelo utilizaremos los data sets que contienen la información de las reservaciones modelados como curvas de "pick up". Estas curvas nos describen la velocidad en que un hotel vende su inventario para un día en específico. Lo que el modelo hará es ajustar una curva que resuma el comportamiento del hotel para un día similar al que se está estudiando, de esa manera podremos predecir cuantos cuartos venderá el hotel y con cuantos días de antelación.Para lograr esto se construirá un modelo de regresión Poisson fundamentado en la distribución de la llegada de las reservaciones como un proceso discreto que depende del tiempo y para darle un enfoque de uso predictivo al modelo, se utiliza un modelo de regresión lineal con predictores que dependen del tiempo para dar un valor estimado por día y por hotel de las curvas de "pick Up".
\paragraph{Modelo de regresión Poisson} ~\\
Por la naturaleza del estudio que se está realizando se optó por implementar una regresión Poisson, la cuál es un modelo linear genearlizado usado comúnmente en problemas de conteos de datos y tablas de contingencia. La regresión de Poisson asume que la variable de respuesta $Y$ tiene una distribución de Poisson y también asume que el logaritmo de su valor esperado puede ser modelado por una comibinación lineal de los parámetros desconocidos.
El modelo de regresión Poisson puede ser expresado como sigue:
$$\log(E(Y|X))=\beta_0 + \beta_1{X}$$
Para poder aplicar el modelo a la información proporcionada, se contruyeron series por día y hotel en función del número de días de antelación para la reservación.
~\\
La selección del modelo de regresión Poisson se fundamenta en la distribución de la llegada de las reservaciones como un proceso discreto que depende del tiempo. El conteo de las reservaciones es inversamente proporcional a la cercanía de la fecha de entrada al hotel y por tanto la probabilidad de ocurrencia de llenado del hotel incrementa conforme se acerca la fecha para la que se hace la reservación.

\paragraph{Modelo de regresión lineal} ~\\
Considerando que las principales variables que describen la predictividad de la demanda son temporales, se propone un modelo que explique los parámetros de las curvas de "pick up" mediante un modelo lineal. Se generan series temporales para hacer predictivo el modelo de pronóstico de demanda y proyectamos en función de la historia en el mismo día calendario del año anterior, el día de la semana para compensar los efectos diferenciados por hotel, así como los eventos que afectan la demanda en un calendario anticipado por hotel, y finalmente el comportamiento de las tarifas que ofrece la competencia.
$$\log(E(Y|X))=\beta_0 + \beta_1{X}$$
\subsection{Interpretación del modelo}
El modelo genera como resultado un data set similar al que se muestra a continuación:
~\\
<<Modelo, echo=FALSE>>=
library(plyr)
HIS_CEINS<-read_csv("datos/EST_PAS_UNIC_CEINS.csv")
RES_CEINS <- read.csv("datos/CEINS_RESERVAS.csv")
#Juntamos todas las tablas en un solo dataset
#datos <- rbind(HIS_CEINS, RES_CEINS)
datos <- HIS_CEINS
#Modelo de regresión Poisson para obtener parámetros de modelo predictivo
modelo.1<-function(base,h){
  hotel<-subset(base,prop_code==h)
  dia<-sort(unique(hotel$date_in))
  ndia<-length(dia)
  beta0<-rep(0,ndia)
  beta1<-rep(0,ndia)
  variacion<-rep(0,ndia)
  for(i in 1:ndia){
    eleccion <- ddply(subset(hotel,as.character(date_in)==as.character(dia[i]),
                             select = c('antelacion','nights')),
                      .(antelacion),summarise, nights = sum(nights))
    eleccion <- eleccion[with(eleccion,order(-antelacion)), ]
    eleccion$nights <- cumsum(eleccion$nights)
    eleccion <- eleccion[eleccion$antelacion<=60,]
    mod <- glm(nights~antelacion, family = "poisson", data = eleccion)
    coeficientes <- coef(mod)
    beta0[i] <- coeficientes[1]
    beta1[i]<- coeficientes[2]
    variacion[i] <- sqrt(mod$deviance)
  }
  yresp <- data.frame(hotel=rep(h,ndia),dia,beta0,beta1,variacion)
  return(yresp)
}

# Prepara datos 2017 de entrada del modelo
res <- ddply(datos,.(prop_code,date_create,date_in), summarise, nights=sum(nights))
res$prop_code<-toupper(res$prop_code)
res$antelacion <- as.numeric(res$date_in - res$date_create)
res <- subset(res,format(res$date_in, "%Y")=="2017")
yresp.1 <- modelo.1(res,"CEINS")
#yresp <- rbind(yresp.1, yresp.2, yresp.3, yresp.4, yresp.5, yresp.6)
yresp<-yresp.1


### Preparación de datos para modelo predictivo (2018)
series2018 <- subset(yresp,format(yresp$dia, "%Y")=="2017")
series2018$dia <- as.Date(series2018$dia)+365
names(series2018) <- c("hotel","dia","AAbeta0","AAbeta1","AAvariacion")

### Series a la fecha de corte en la extracción

#Reservas
RES_CEXXX<-RES_CEINS
#
res<-RES_CEXXX
res <- ddply(res,.(prop_code,date_create,date_in), summarise, nights=sum(nights))
res$prop_code<-toupper(res$prop_code)
res<-res %>% filter(date_create!="0000-00-00 00:00:00") %>% 
  mutate(date_create=as.Date(date_create),
  date_in=as.Date(date_in))
res$antelacion <- as.numeric(res$date_in - res$date_create)
series2018al11ago <- subset(series2018,as.numeric(dia)<as.numeric(as.Date("2018-08-11")))
res2018al11ago <- subset(res,as.numeric(date_in)<as.numeric(as.Date("2018-08-11")))
res2018al11ago <- subset(res2018al11ago,format(res2018al11ago$date_in, "%Y")=="2018")

### Aplicación del modelo a la fecha de corte por extracción
param.1 <- modelo.1(res2018al11ago,"CEINS")

#param2018 <- rbind(param.1, param.2, param.3, param.4, param.5, param.6)
param2018 <- param.1
series2018al11ago <- join(series2018al11ago,param2018)

### Generación de predictores de modelo predictivo
series2018al11ago$diasem <- as.factor(weekdays(series2018al11ago$dia))
series2018al11ago$mes <- as.factor(format(series2018al11ago$dia, "%b"))
series2018al11ago <- join(series2018al11ago,TDC)
series2018al11ago$eventos <- rep(0,nrow(series2018al11ago))
series2018al11ago$eventos <- as.factor(ifelse(as.numeric(series2018al11ago$dia)
                             <=as.numeric(as.Date("2018-08-11")) & 
                               as.numeric(series2018al11ago$dia)>=
                               as.numeric(as.Date("2018-03-27")),1,0))
#series2018al11ago <-join(series2018al11ago,eventos)
series2018al11ago$eventos<-as.factor(series2018al11ago$eventos)
PO_PT <- indicadores %>% select(Hotel,fecha,po,pt)

names(PO_PT) <- c("hotel","dia","PO","PT")
series2018al11ago <- join(series2018al11ago,PO_PT)

### Generación de modelos predictivos por hotel
#CEINS
datos2018al11agoCEINS <- subset(series2018al11ago,hotel=="CEINS")
mod.CEINS.beta0 <- lm(beta0~AAbeta0+diasem+eventos+tdc+PO+PT,
                      data=datos2018al11agoCEINS)
datos2018al11agoCEINS$pred.beta0 <-predict(mod.CEINS.beta0,type='response')
datos2018al11agoCEINS$AAbeta1[is.na(datos2018al11agoCEINS$AAbeta1)]<-0
mod.CEINS.beta1 <- lm(beta1~AAbeta1+diasem+eventos+tdc+PO+PT,
                      data=datos2018al11agoCEINS)
datos2018al11agoCEINS$pred.beta1<-predict(mod.CEINS.beta1,type='response')

### Aplica los modelos a la serie completa 2018
series2018 <- join(series2018,TDC)
series2018$AAbeta1[is.na(series2018$AAbeta1)]<-0
series2018 <- join(series2018,PO_PT)
series2018$diasem <- as.factor(weekdays(series2018$dia))
series2018$mes <- as.factor(format(series2018$dia, "%b"))

series2018$eventos1 <- ifelse(as.numeric(series2018$dia)<=
                                as.numeric(as.Date("2018-04-04")) & 
                                as.numeric(series2018$dia)>=
                                as.numeric(as.Date("2018-03-27")),1,0)

series2018$eventos <- series2018$eventos1
series2018$eventos <- as.factor(series2018$eventos)
series2018$pred.beta0 <- ifelse(series2018$hotel=="CEINS",
                                predict(mod.CEINS.beta0,newdata=series2018,type="response"),0)
series2018$pred.beta1 <- ifelse(series2018$hotel=="CEINS",
                                predict(mod.CEINS.beta1,newdata=series2018,type="response"),0)

head(series2018)

@
~\\
Las variables de interés son: "pred.beta0" y "pred.beta1" ya que son los parámetros generados por los modelos y que nos ayudarán a reconstruír las curvas de pickup. Para reconstruír la curva de pickup de un día en específico, debemos obtener los parámetros "pred.beta0" y "pred.beta1" para el día elegido y posteriormente debemos calcular hacer el siguiente cálculo: $$E[y|x]=e^{\beta_0 + \beta_1{x}}$$
~\\
Dónde:
\begin{itemize}[noitemsep]
\item $E[y|x]$ = El valor esperado de cuartos noches para un día en específico
\item $\beta_0$ = pred.beta0
\item $\beta_1$ = pred.beta1
\item $x$ = días de antelación al día analizado
\end{itemize}
~\\
Validamos el modelo con fechas aleatorias y obtenemos las siguientes gráficas:
~\\
<<ValidacionModelo, echo=FALSE, fig.width=20, fig.height=15>>=
detach(package:plyr)
library(dplyr)
#2018-01-17
dias<-series2018 %>% select(dia) %>% 
  filter(dia<='2018-08-11')
val<-sample(1:223,30)
i<-1
plots<-list()
mape<-list()
for(index in val){
fecha<-dias[index,]
beta0<-as.numeric(series2018 %>% filter(dia==fecha) %>% select(pred.beta0)) 
beta1<-as.numeric(series2018 %>% filter(dia==fecha) %>% select(pred.beta1)) 
antelacion <- seq(1:62)-2
cn_predic<-as.integer(exp(beta0 + beta1*antelacion))
test_result<-as.data.frame(cbind(antelacion,cn_predic))

datos_reales <- RES_CEINS %>% filter(as.character(date_in) == fecha) %>% 
                select(date_create,date_in,nights) %>% 
                mutate(date_create = as.Date(date_create),
                       date_in = as.Date(date_in))

datos_reales$antelacion<-as.integer(difftime(datos_reales$date_in,datos_reales$date_create, units="days"))
datos_reales <- datos_reales %>% arrange(-antelacion)

datos_reales <- datos_reales %>% select(antelacion,nights) %>% dplyr::group_by(antelacion) %>% 
                summarise(cn=sum(nights))

datos_reales$cumsum <- rev(cumsum(rev(datos_reales$cn))) 

datos_reales<- datos_reales %>% select(antelacion,cumsum)
plots[[i]]<-ggplot(data=test_result, aes(antelacion,cn_predic),guide=TRUE)+
  geom_point()+geom_line(data=datos_reales, aes(x=antelacion,y=cumsum, colour="red"))+
  xlab("Antelacion")+ylab("Cuartos Vendidos")
i<-i+1

resultados_mape<-test_result[1:29,]
MAPE_DS<- datos_reales %>% inner_join(resultados_mape)
MAPE_DS$MAPE<-(MAPE_DS$cumsum-MAPE_DS$cn_predic)/MAPE_DS$cumsum

mape[[i]] <- (sum(MAPE_DS$MAPE)/29)*100

}
cowplot::plot_grid(plotlist = plots, ncol = 4)
@

<<Caluclo MAPE, echo=FALSE, fig.width=20, fig.height=15>>=
detach(package:plyr)
library(dplyr)
#2018-01-17
antelacion <- -1
validacion_mape<-series2018 %>% select(dia,pred.beta0,pred.beta1) %>% 
  filter(dia<='2018-08-11')

validacion_mape$cn_predic<-as.integer(exp(validacion_mape$pred.beta0 + validacion_mape$pred.beta1*antelacion))

reales <- res2018al11ago %>% select(date_in,nights) %>%  group_by(date_in) %>% 
  summarise(cuartos=sum(nights))
names(reales)<-c("dia","cuartos_reales")

validacion_mape<- validacion_mape %>% inner_join(reales)

validacion_mape$mape<- (abs(validacion_mape$cuartos_reales - validacion_mape$cn_predic))/validacion_mape$cuartos_reales

print("mape:")
(sum(validacion_mape$mape)/nrow(validacion_mape))*100
@
~\\
\paragraph{Modelo simple de pricing dinámico}~\\
Una vez pronósticado el nível de ocupación para cada una de las propiedades de la cadena, se alimentó un modelo de pricing dinámico que entrega recomendaciones de precios para la tarifa pública tomando en cuenta la demanda pronósticada para cierto día del año.

~\\
\subparagraph{Problema de asignación de precios}~\\
Típicamente el gerente de la propiedad controla la cantidad de cuartos ofrecidos a diferentes precios, es decir, se asigna cierto número de cuartos a cada nível de tarifa de tal forma que cuando el inventario asignado al precio mas bajo se agota, se consume el inventario asignado al siguiente nivel de tarifa que será mayor al primer precio ofertado. 
~\\
A continuación se muestra un esquema donde se ejemplifica la idea mencionada anteriormente:

\begin{figure}[!]
  \includegraphics[width=\linewidth]{Imagenes/buckets.png}
  \caption{Asignacion de inventario}
  \label{fig:Asignacion de Inventario}
\end{figure}

~\\
Como se puede observar, tenemos un inventario de 32 cuartos divido en 4 níveles de precios:
\begin{itemize}[noitemsep]
\item 12 cuartos son ofrecidos a un valor de 110 USD
\item 8 cuartos son ofrecidos a un valor de 120 USD
\item 7 cuartos son ofrecidos a un valor de 130 USD
\item 5 cuartos son ofrecidos a un valor de 155 USD
\end{itemize}
~\\
Hay que considerar que el hecho de poder encontrar el precio que maximiza el ingreso de una propiedad constituye un problema complejo de optimización, en donde el hotel debería explorar un gran número de escenarios, sin embargo, para superar la complejidad computacional que este calculo requiere muchos hoteles han optado por usar varias simplificaciones por ejemplo, utilizar un enfoque basado en la asignación de precios, en la cual se pre asigna un número fijo de inventario disponible a cada nível de precios y los precios pueden variar a lo largo del tiempo.
~\\
\subparagraph{Formulación Matemática}~\\
Un problema de maximización de ingresos es básicamente un problema de optimización sujeto a restricciones, en este caso, se quiere maximizar la siguiente función objetivo:
$$\sum_{n=0}^{n}p_i*o_i$$
En donde i es la índice de la noche, $p_i$ es el precio del cuarto para la i-ésima noche y $o_i$ es la ocupación pronósticada (demanda) para la i-ésima noche al precio $p_i$. Asumimos también que la función de la ocupación (demanda) está sujeta al precio bajo la siguiente relación:
$$o = o_{nominal} * (\frac{p}{p_{nominal}})^e$$
Donde $o_{nominal}$ corresponde a la ocupación pronosticada para una noche dada tomando como base un precio nominal ($p_{nominal}$). Para este caso el $p_{nominal}$ es igual a la tarifa pública promediada a lo largo del año. El valor de $e$ (elasticidad) toma un valor = -2. En otras palabras, $p$ incrementa en un 10\% y la demanda decrece cerca de un 20\%.
~\\
Para poder hacer una asignación dinámica de los precios, evitando tener que correr el modelo conforme la información del hotel es actualizada, se partió el inventario en 4 níveles de disponiblidad (159,120,80 y 40 cuartos disponibles). Para cada nível de capacidad se resolvió la función objetivo para obtener 4 conjuntos de precios, de esta forma, el gerente de la propiedad puede saber a qué nível de precio debe subir la tarifa pública de la propiedad conforme las habitaciones disponibles decrecen.
~\\
\subparagraph{Limitantes del modelo}~\\
Este modelo se formuló considerando los siguientes puntos:
\begin{itemize}[noitemsep]
  \item Se consideran estancias de una sola noche
  \item No se toman en cuenta reservaciones para grupos ni cancelaciones
  \item Asusmimos paridad de precios entre los canales, es decir, los precios no varían entre los canales de venta
  \item Se considera solamente un tipo de habitación, el incremento por cambio de habitación es un monto fijo conocido como gap
  \item Se asume un valor para la elasticidad (-2) que es un valor razonable para la industria
\end{itemize}

<<Forecasted_Demand, echo=FALSE, fig.width=20, fig.height=15>>=
param_pricing_ocup<-series2018 %>% select(dia,pred.beta0,pred.beta1)
param_pricing_ocup$cn_predic <- as.integer(exp(param_pricing_ocup$pred.beta0 + param_pricing_ocup$pred.beta1*0))
param_pricing_ocup$ocup<-as.integer((param_pricing_ocup$cn_predic/159)*100)
pricing_ocup <- param_pricing_ocup %>%  select (dia, cn_predic) %>% filter(dia <= "2018-08-11")
write_csv(pricing_ocup,"result/forecasted_demand.csv")
write_csv(pricing_ocup, "jupyter/data/forecasted_demand.csv")
@
\subparagraph{Resultados del modelo de pricing}~\\
El modelo de pricing, como comentarmos anteriormente, arroja como resultado una matriz de día vs precio por niveles de inventario. A continuación se muestra un ejemplo:
~\\
<<Pricing, echo=FALSE, fig.width=20, fig.height=15>>=
prices<-read_csv("jupyter/data/rates.csv")
prices<-as.data.frame(prices)
names(prices)<-c("day","40","80","120","159")
prices[sample(nrow(prices), 10), ]
pricing_ocup$habs_disp<-159-pricing_ocup$cn_predic

prices$tp_pron<-(prices$`40` + prices$`80` + prices$`120` + prices$`159`) / 4
tp_real <- indicadores %>%  select(fecha, tp) %>% filter(fecha>= '2018-01-01')
names(tp_real)<-c("day","tp")

prices <- prices %>% inner_join(tp_real)

price_result <- prices %>% select(day,tp_pron, tp)

price_result <- price_result %>% gather(day)
names(price_result)<-c("day","Rate_type","Value") 

ggplot(price_result,aes(day,Value, col=Rate_type))+geom_line()
#head(pricing_ocup)
@
~\\
Graficando los resultados:
~\\
<<Pricing_graph, echo=FALSE, fig.width=20, fig.height=15>>=
head(prices)
prices_tidy <- prices %>% gather('habs_disp','tarifa',2:5)
ggplot(data=prices_tidy,aes(x=day,y=tarifa, col=habs_disp))+geom_line()
@
\section{Anexo A: Implementación del modelo pronóstico de demanda}
<<AnexoModelo, echo=TRUE, eval=FALSE>>=
library(plyr)
HIS_CEINS<-read_csv("datos/EST_PAS_UNIC_CEINS.csv")
RES_CEINS <- read.csv("datos/CEINS_RESERVAS.csv")
#Juntamos todas las tablas en un solo dataset
#datos <- rbind(HIS_CEINS, RES_CEINS)
datos <- HIS_CEINS
#Modelo de regresion Poisson para obtener
#parametros de modelo predictivo
modelo.1<-function(base,h){
  hotel<-subset(base,prop_code==h)
  dia<-sort(unique(hotel$date_in))
  ndia<-length(dia)
  beta0<-rep(0,ndia)
  beta1<-rep(0,ndia)
  variacion<-rep(0,ndia)
  for(i in 1:ndia){
    eleccion <- ddply(subset(hotel,as.character(date_in)==
                               as.character(dia[i]),
                             select = c('antelacion','nights')),
                      .(antelacion),summarise, 
                      nights = sum(nights))
    eleccion <- eleccion[with(eleccion,order(-antelacion)), ]
    eleccion$nights <- cumsum(eleccion$nights)
    eleccion <- eleccion[eleccion$antelacion<=60,]
    mod <- glm(nights~antelacion, family = "poisson", 
               data = eleccion)
    coeficientes <- coef(mod)
    beta0[i] <- coeficientes[1]
    beta1[i]<- coeficientes[2]
    variacion[i] <- sqrt(mod$deviance)
  }
  yresp <- data.frame(hotel=rep(h,ndia),dia,beta0,beta1,variacion)
  return(yresp)
}

# Prepara datos 2017 de entrada del modelo
res <- ddply(datos,.(prop_code,date_create,date_in), 
             summarise, nights=sum(nights))
res$prop_code<-toupper(res$prop_code)
res$antelacion <- as.numeric(res$date_in - res$date_create)
res <- subset(res,format(res$date_in, "%Y")=="2017")
yresp.1 <- modelo.1(res,"CEINS")
yresp<-yresp.1


### Preparacion de datos para modelo predictivo (2018)
series2018 <- subset(yresp,format(yresp$dia, "%Y")=="2017")
series2018$dia <- as.Date(series2018$dia)+365
names(series2018) <- c("hotel","dia","AAbeta0",
                       "AAbeta1","AAvariacion")

### Series a la fecha de corte en la extraccion

#Reservas
RES_CEXXX<-RES_CEINS
#
res<-RES_CEXXX
res <- ddply(res,.(prop_code,date_create,date_in), 
             summarise, nights=sum(nights))
res$prop_code<-toupper(res$prop_code)
res<-res %>% filter(date_create!="0000-00-00 00:00:00") %>% 
  mutate(date_create=as.Date(date_create),
  date_in=as.Date(date_in))
res$antelacion <- as.numeric(res$date_in - res$date_create)
series2018al11ago <- subset(series2018,as.numeric(dia)<
                              as.numeric(as.Date("2018-08-11")))
res2018al11ago <- subset(res,as.numeric(date_in)<
                           as.numeric(as.Date("2018-08-11")))
res2018al11ago <- subset(res2018al11ago,
                  format(res2018al11ago$date_in, "%Y")=="2018")

### Aplicacion del modelo a la fecha de corte por extraccion
param.1 <- modelo.1(res2018al11ago,"CEINS")

param2018 <- param.1
series2018al11ago <- join(series2018al11ago,param2018)

### Generacion de predictores de modelo predictivo
series2018al11ago$diasem <- as.factor(weekdays
                                      (series2018al11ago$dia))
series2018al11ago$mes <- as.factor(format(
  series2018al11ago$dia, "%b"))
series2018al11ago <- join(series2018al11ago,TDC)
series2018al11ago$eventos <- rep(0,nrow(series2018al11ago))
series2018al11ago$eventos <- as.factor(ifelse(
                               as.numeric(series2018al11ago$dia)
                             <=as.numeric(as.Date("2018-08-11")) & 
                               as.numeric(series2018al11ago$dia)>=
                               as.numeric(as.Date("2018-03-27")),
                               1,0))
#series2018al11ago <-join(series2018al11ago,eventos)
series2018al11ago$eventos<-as.factor(series2018al11ago$eventos)
PO_PT <- indicadores %>% select(Hotel,fecha,po,pt)

names(PO_PT) <- c("hotel","dia","PO","PT")
series2018al11ago <- join(series2018al11ago,PO_PT)

### Generacion de modelos predictivos por hotel
#CEINS
datos2018al11agoCEINS <- subset(series2018al11ago,hotel=="CEINS")
mod.CEINS.beta0 <- lm(beta0~AAbeta0+diasem+eventos+tdc+PO+PT,
                      data=datos2018al11agoCEINS)
datos2018al11agoCEINS$pred.beta0 <-predict(mod.CEINS.beta0,
                                           type='response')
datos2018al11agoCEINS$AAbeta1[is.na(
                             datos2018al11agoCEINS$AAbeta1)]<-0
mod.CEINS.beta1 <- lm(beta1~AAbeta1+diasem+eventos+tdc+PO+PT,
                      data=datos2018al11agoCEINS)
datos2018al11agoCEINS$pred.beta1<-predict(mod.CEINS.beta1,
                                          type='response')

### Aplica los modelos a la serie completa 2018
series2018 <- join(series2018,TDC)
series2018$AAbeta1[is.na(series2018$AAbeta1)]<-0
series2018 <- join(series2018,PO_PT)
series2018$diasem <- as.factor(weekdays(series2018$dia))
series2018$mes <- as.factor(format(series2018$dia, "%b"))

series2018$eventos1 <- ifelse(as.numeric(series2018$dia)<=
                                as.numeric(as.Date("2018-04-04")) & 
                                as.numeric(series2018$dia)>=
                                as.numeric(as.Date("2018-03-27")),
                                1,0)

series2018$eventos <- series2018$eventos1
series2018$eventos <- as.factor(series2018$eventos)
series2018$pred.beta0 <- ifelse(series2018$hotel=="CEINS",
                                predict(mod.CEINS.beta0,
                                        newdata=series2018,
                                        type="response"),0)
series2018$pred.beta1 <- ifelse(series2018$hotel=="CEINS",
                                predict(mod.CEINS.beta1,
                                        newdata=series2018,
                                        type="response"),0)
@

\section{Anexo B: Implementación del Modelo de Pricing}
<<Pricing_ANEXO, echo=TRUE, eval=FALSE, fig.width=20, fig.height=15>>=
import pandas as pd
import numpy as np
import scipy
import math as mt
import pickle as pkl
import os
import psycopg2
import matplotlib
import matplotlib.pyplot as plt
from numpy.random import normal
import calendar
from scipy.optimize import curve_fit
%matplotlib inline
plt.rcParams['figure.figsize'] = (16,8)
import warnings
warnings.filterwarnings('ignore')
import plotly.plotly as py
import plotly.graph_objs as go
import plotly.figure_factory as ff
from plotly.offline import download_plotlyjs, 
init_notebook_mode, plot, iplot
init_notebook_mode(connected=True)
from datetime import datetime
from datetime import timedelta

# Cargamos los resultados de la regresion poisson para pronosticar ocupacion
data = pd.read_csv("data/forecasted_demand.csv")
date_start = min(data.dia.values)
date_end = max(data.dia.values)
date_end=datetime.strptime(date_end, '%Y-%m-%d')
date_end= date_end +  timedelta(days=1)
nb_days = (pd.to_datetime(date_end) - pd.to_datetime(date_start)).days
forecasted_demand = data.cn_predic.values
forecasted_demand=pd.DataFrame(forecasted_demand,
                               index=pd.date_range(start=date_start,
                                                   end=date_end,closed='left'),
                               columns=['occupancy'])
forecasted_demand.occupancy=data.cn_predic.values


# Let's assume a demand price elasticity function:

def demand_price_elasticity(price, nominal_demand, elasticity=-2.0, nominal_price=120.0):
    """Returns demand given a value for the elasticity, nominal demand and nominal price.

    Parameters
    ----------

    price (numpy.ndarray):
        one-dimensional price array. The length of that array should correspond to the
        length of the forecast period.

    nominal_demand (numpy.ndarray):
        one-dimensional forecasted occupancy array. The length of that array should
        correspond to the length of the forecast period.

    elasticity (float):
        value of the elasticity between price and demand. A value of e=-2 is reasonable.

    nominal_price (float):
        room rate for which the forecast was computed.

    Returns
    -------

    A numpy.ndarray of expected demand.
    """

    return nominal_demand * ( price / nominal_price ) ** (elasticity)

import scipy.optimize as optimize

# definition of the objective function:

def objective(p_t, nominal_demand=np.array([50,40,30,20]),
              elasticity=-2.0, nominal_price=1200.0):
    """
    Definition of the objective function. This is the function that want to minimize.
    (minus sign in front)

    Parameters
    ----------

    p_t (numpy.ndarray):
        one-dimensional price array. The length of that array should correspond to the
        length of the forecast period.

    nominal_demand (numpy.ndarray):
        one-dimensional forecasted occupancy array. The length of that array should
        correspond to the length of the forecast period.

    elasticity (float):
        value of the elasticity between price and demand. A value of e=-2 is
        reasonable.

    nominal price (float):
        room rate for which the forecast was computed.

    Returns
    -------

    Value of the objective function (float).

    Note: here we're trying to minimize the objective function. That's where the
    minus sign comes_in.

    """

    return (-1.0 * np.sum( p_t * demand_price_elasticity(p_t, nominal_demand=nominal_demand,
                                                        elasticity=elasticity,
                                                        nominal_price=nominal_price) )) / 100

def constraint_1(p_t):
    """ This constraint ensures that the prices are positive.
    """
    return p_t


def constraint_2(p_t, capacity=20, forecasted_demand=35.0,
                 elasticity=-2.0, nominal_price=1200.0):
    """ This constraint ensures that the demand does not exceed
    capacity.

    Parameters
    ----------

    p_t (float):
        Room price

    capacity (integer):
        Capacity of the hotel (in rooms).

    forecasted_demand (float):
        Forecasted demand (in rooms) for that night

    elasticity (float):
        slope of the

    nominal_price (float):
        The price for which the forecasted_demand was computed.

    Returns
    -------
    Returns an array of excess capacity.

    """
    return capacity - demand_price_elasticity(p_t, nominal_demand=forecasted_demand,
                                                        elasticity=elasticity,
                                                        nominal_price=nominal_price)

# Let's run the optimization algorithm over four overlapping segments
# of 20, 40, 60, 80 room capacity.

# We look at four capacity segments: 20, 40, 60, and 80 (full capacity)
# rooms available.
capacities = [20.0, 40.0, 60.0, 80.0]

optimization_results = {}
for capacity in capacities:

    # Nominal price associated with forecasted demand:
    nominal_price = 1200.0
    # Forecasted demand:
    nominal_demand = forecasted_demand['occupancy'].values
    # Assumed price elasticity:
    elasticity = -2.0

    # Starting values:
    p_start = 1250.0 * np.ones(len(nominal_demand))

    # bounds on the prices. Let's stick with reasonable values.
    # One could be more sophisticated here and apply constraints
    # that limit the prices to be in range of what competitors
    # are charging, for example.
    bounds = tuple((100.0, 2000.0) for p in p_start)

    # Constraints:
    constraints = ({'type': 'ineq', 'fun':  lambda x:  constraint_1(x)},
               {'type': 'ineq', 'fun':  lambda x, capacity=capacity,
                                           forecasted_demand=nominal_demand,
                                           elasticity=elasticity,
                                           nominal_price=nominal_price: constraint_2(x,capacity=capacity,
                                                                                     forecasted_demand=nominal_demand,
                                                                                     elasticity=elasticity,
                                                                                     nominal_price=nominal_price)})

    opt_results = optimize.minimize(objective, p_start, args=(nominal_demand,
                                                              elasticity,
                                                              nominal_price),
                                    method='SLSQP', bounds=bounds,
                                    constraints=constraints)

    optimization_results[capacity] = opt_results
    
# Plotting the resulting rates vs dates.

time_array = np.linspace(1,len(nominal_demand),len(nominal_demand))
rate_df = pd.DataFrame(index=time_array)

for capacity in optimization_results.keys():
    rate_df = pd.concat([rate_df,
                         pd.DataFrame(optimization_results[capacity]['x'],
                                      columns=['{}'.format(capacity)],
                                      index=time_array)],
                        axis=1)

rate_df.index.name = 'Day'
datelist = pd.date_range(start=date_start, end=date_end, closed='left').tolist()
rate_df.index = [ x.date() for x in datelist]

# Save rate dataframe to local folder:

rate_df.to_csv('data/rates.csv')



@

\section{Referencias}
\end{document}

